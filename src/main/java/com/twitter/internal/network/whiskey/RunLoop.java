package com.twitter.internal.network.whiskey;

import android.support.annotation.NonNull;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
  Manages a single thread for handling event-based execution generated by both the
  application interface and socket connections.
 */
class RunLoop implements Executor {

    private static RunLoop instance;

    private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();
    private final PriorityBlockingQueue<ScheduledRunnable> scheduledTasks = new PriorityBlockingQueue<>(1, ScheduledRunnable.Comparator());;
    private final Selector selector;
    private final RunLoopThread thread = new RunLoopThread();

    private int executions = 0;
    private int loops = 0;

    private volatile boolean paused = false;
    private volatile boolean selecting = false;

    RunLoop() throws IOException {
        selector = Selector.open();
    }

    synchronized static RunLoop instance() {
        if (instance == null) {
            try {
                instance = new RunLoop();
            } catch (IOException e) {
                // Apparently this is platform specific: it can in theory happen on Windows, but
                // never on Linux. On Android... who knows? Not much we can do if it happens.
                throw new RuntimeException(e);
            }
        }
        return instance;
    }

    public void startThread() {
        thread.start();
    }

    public void stopThread() throws InterruptedException {
        paused = true;

        if (selecting) {
          selector.wakeup();
        }

        thread.join();
    }

    /**
     * Executes the runnable on the internal RunLoopThread, waking the selector if necessary.
     */
    @Override
    public void execute(@NonNull Runnable command) {
        tasks.add(command);
        // TODO: investigate and fix race if necessary - documentation seems to indicate it won't be
        if (selecting) {
            selector.wakeup();
        }
    }

    /**
     * Schedules the runnable for future execution on the internal RunLoopThread.
     *
     * @param command the runnable to execute
     * @param delay the delay to wait before execution
     * @param tolerance window of time past the specified delay that execution is still allowed. If
     *                  this is set to 0, then the command will still be executed regardless of how
     *                  much additional time may have passed.
     * @param unit time unit of both the specified delay and tolerance
     */
    public void schedule(@NonNull Runnable command, long delay, long tolerance, @NonNull TimeUnit unit) {

        if (delay < 0 || tolerance < 0) {
            throw new IllegalArgumentException();
        }

        long triggerPoint = PlatformAdapter.get().timestamp() + unit.toMillis(delay);
        scheduledTasks.add(new ScheduledRunnable(command, triggerPoint, unit.toMillis(tolerance)));
        // TODO: investigate and fix race if necessary - documentation seems to indicate it won't be
        if (selecting) {
            selector.wakeup();
        }
    }

     /**
     * Registers socket events to be handled on the internal RunLoopThread. This method is
     * unsynchronized, and may block if not called from the internal RunLoopThread.
     */
     // TODO: provide selectionkey to socket on cancelation for close?
    @SuppressWarnings("ResourceType")
    void register(Socket socket) {

        try {
            int interestSet = socket.interestSet();
            if (interestSet == 0) return;

            SelectionKey key = socket.getChannel().register(selector, interestSet);
            key.attach(socket);
        } catch(ClosedChannelException e) {
            socket.onClose();
        }
    }

    public void loop() {

        loops++;

        // Check standard tasks
        Runnable currentTask;
        while ((currentTask = tasks.poll()) != null) {
            executions++;
            currentTask.run();
        }

        long selectTimeout = 0;

        // Check scheduled tasks and setup maximum delay
        ScheduledRunnable nextScheduledTask;
        while (!scheduledTasks.isEmpty()) {
            nextScheduledTask = scheduledTasks.peek();
            long now = PlatformAdapter.get().timestamp();
            if (nextScheduledTask.triggerPoint <= now - nextScheduledTask.tolerance) {
                // Discard the task - we missed the tolerance window
                scheduledTasks.poll();
            } else if (nextScheduledTask.triggerPoint <= now) {
                // It's time to run the task
                executions++;
                nextScheduledTask.run();
                scheduledTasks.poll();
            } else {
                // Determine the select timeout and break
                selectTimeout = nextScheduledTask.triggerPoint - now;
                break;
            }
        }

        int readyChannels = 0;

        // Select
        try {
            selecting = true;
            readyChannels = selector.select(selectTimeout);
            selecting = false;
        } catch (IOException e) {
            // TODO: handle closed channels
            System.err.println("select exception: " + e);
        }

        if (readyChannels > 0) {
            Set<SelectionKey> selected = selector.selectedKeys();
            for (Iterator<SelectionKey> iterator = selected.iterator(); iterator.hasNext(); ) {
                SelectionKey key = iterator.next();
                iterator.remove();

                Object attachment = key.attachment();
                if (attachment instanceof Socket) {
                    Socket socket = (Socket) attachment;
                    if (key.isConnectable()) {
                        executions++;
                        socket.onConnect();
                    } else if (key.isReadable()) {
                        executions++;
                        socket.onReadable();
                    } else if (key.isWritable()) {
                        executions++;
                        socket.onWriteable();
                    }
                }
            }
        }
    }

    // TODO: figure out liveness
    // TODO: allow cancelation of scheduled tasks?
    private class RunLoopThread extends Thread {

        @Override
        public void run() {
            while (!paused) {
                loop();
            }
        }
    }

    private static class ScheduledRunnable implements Runnable {
        public long triggerPoint;
        public long tolerance;
        private Runnable runnable;

        ScheduledRunnable(Runnable runnable, long triggerPoint, long tolerance) {
            this.runnable = runnable;
            this.triggerPoint = triggerPoint;
            this.tolerance = tolerance;
        }

        @Override
        public void run() {
            runnable.run();
        }

        public static Comparator<ScheduledRunnable> Comparator() {
            return new Comparator<ScheduledRunnable>() {
                @Override
                public int compare(ScheduledRunnable lhs, ScheduledRunnable rhs) {
                    return (int)(lhs.triggerPoint - rhs.triggerPoint);
                }
            };
        }
    }
}
