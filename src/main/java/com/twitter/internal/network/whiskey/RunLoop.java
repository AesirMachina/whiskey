package com.twitter.internal.network.whiskey;

import android.support.annotation.NonNull;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
  Manages a single thread for handling network events generated by both the
  application interface and socket connections.
 */
class RunLoop implements Executor {

    private static RunLoop instance;

    private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();
    private final Selector selector;
    private final RunLoopThread thread = new RunLoopThread();
    private final Object threadLock = new Object();

    private int executions = 0;
    private int loops = 0;

    private volatile boolean paused = false;
    private volatile boolean selecting = false;

    RunLoop() throws IOException {
        selector = Selector.open();
    }

    synchronized static RunLoop instance() {
        if (instance == null) {
            try {
                instance = new RunLoop();
            } catch (IOException e) {
                // Apparently this is platform specific: it can in theory happen on Windows, but
                // never on Linux. On Android... who knows? Not much we can do if it happens.
                throw new RuntimeException(e);
            }
        }
        return instance;
    }

    /**
     * Executes the runnable on the internal SpdyNetworkThread, waking up the selector if necessary.
     */
    @Override
    public void execute(@NonNull Runnable command) {
        tasks.add(command);
        if (selecting) {
            selector.wakeup();
        }
    }

    public void schedule(@NonNull Runnable command, long delay, TimeUnit unit) {

    }

     /**
     * Register socket events to be handled on the internal RunLoopThread. This method is
     * unsynchronized, and may block if not called from the internal RunLoopThread.
     */
    @SuppressWarnings("ResourceType")
    void register(Socket socket) {

        try {
            int interestSet = socket.interestSet();
            if (interestSet == 0) return;

            SelectionKey key = socket.getChannel().register(selector, interestSet);
            key.attach(socket);
        } catch(ClosedChannelException e) {
            socket.onClose();
        }
    }

    private class RunLoopThread extends Thread {

        @Override
        public void run() {

            while (!paused /*&& (selector.keys().size() > 0 || tasks.size() > 0)*/) {
                loops++;

                Runnable currentTask;
                while ((currentTask = tasks.poll()) != null) {
                    executions++;
                    currentTask.run();
                }

                try {
                    selecting = true;
                    int readyChannels = selector.select();
                    selecting = false;
                    if (readyChannels > 0) {
                        Set<SelectionKey> selected = selector.selectedKeys();
                        for (Iterator<SelectionKey> iterator = selected.iterator(); iterator.hasNext(); ) {
                            SelectionKey key = iterator.next();
                            iterator.remove();

                            Object attachment = key.attachment();
                            if (attachment instanceof Socket) {
                                Socket socket = (Socket) attachment;
                                if (key.isConnectable()) {
                                    executions++;
                                    socket.onConnect();
                                } else if (key.isReadable()) {
                                    executions++;
                                    socket.onReadable();
                                } else if (key.isWritable()) {
                                    executions++;
                                    socket.onWriteable();
                                }
                            }
                        }
                    }
                } catch (IOException e) {
                    System.err.println("select exception");
                }
            }
        }
    }
}
